{
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "ora": "User Id=system;Password=oracle;Data Source=${DB_HOST}:49000/xe"
  },
  "jwt": {
    "audience": "http://calcomp-icct.org.br",
    "issuer": "calcomp-icct.org.br",
    "secretKey": "C@lc0mp-IcctC@lc0mp-IcctC@lc0mp-IcctC@lc0mp-IcctC@lc0mp-Icct"
  },
  "security": {
    "key": "AXe8YwuIn1zxt3FPWTZFlAa14EHdPAdN9FaZ9RQWihc=",
    "iv": "bsxnWolsAyO7kCfWuyrnqg=="
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "SqlStructDatabase": [
    {
      "TableName": "Authentication",
      "CommandToCreateTable": "CREATE TABLE authentication (ID INTEGER PRIMARY KEY,Username VARCHAR2(16) NOT NULL,RolesName VARCHAR2(50) NOT NULL,Badge VARCHAR2(255) UNIQUE NOT NULL,Password VARCHAR2(50) NOT NULL,Created DATE,LastUpdated DATE)",
      "CommandToSequence": "CREATE SEQUENCE auth_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER auth_trigger BEFORE INSERT ON authentication FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT auth_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": "BEGIN INSERT INTO Authentication (USERNAME, ROLESNAME, BADGE, PASSWORD,CREATED,LASTUPDATED) VALUES ('admin', 'administrador', 'admincompal', 'inNWbDieA4KNSwWeLzW1cQ==',NULL,NULL);INSERT INTO Authentication (USERNAME, ROLESNAME, BADGE, PASSWORD,CREATED,LASTUPDATED) VALUES ('esp32', 'esp32', 'esp32', 'vijPQ5f4YZ9DsG8dCzNKLw==',NULL,NULL);INSERT INTO Authentication (USERNAME, ROLESNAME, BADGE, PASSWORD,CREATED,LASTUPDATED) VALUES ('ueasupervisor', 'ueasupervisor', 'ueasupervisor', 'ZhwdE79iTgym8N8LY53LVg==',NULL,NULL); END;"

    },
    {
      "TableName": "Users",
      "CommandToCreateTable": "CREATE TABLE users (ID INTEGER PRIMARY KEY,Name VARCHAR2(50) NOT NULL,Badge VARCHAR2(255) UNIQUE NOT NULL,Created DATE NOT NULL,LastUpdated DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE users_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER users_trigger BEFORE INSERT ON users FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT users_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "Images",
      "CommandToCreateTable": "CREATE TABLE images (ID INTEGER PRIMARY KEY,UserId INTEGER NOT NULL,Embedding CLOB,Created DATE NOT NULL,LastUpdated DATE NOT NULL,PictureStream BLOB,CONSTRAINT fk_users FOREIGN KEY (UserId) REFERENCES users(ID))",
      "CommandToSequence": "CREATE SEQUENCE images_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER images_trigger BEFORE INSERT ON images FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT images_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "Jig",
      "CommandToCreateTable": "CREATE TABLE jig (ID INTEGER PRIMARY KEY,Name VARCHAR2(50) NOT NULL,SerialNumberJig VARCHAR2(100) NOT NULL UNIQUE,Description VARCHAR2(250),Created DATE NOT NULL,LastUpdated DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE jig_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER jig_trigger BEFORE INSERT ON jig FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT jig_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "Roles",
      "CommandToCreateTable": "CREATE TABLE roles (ID INTEGER PRIMARY KEY,RolesName VARCHAR2(50) UNIQUE NOT NULL,Created DATE,LastUpdated DATE)",
      "CommandToSequence": "CREATE SEQUENCE roles_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER roles_trigger BEFORE INSERT ON roles FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT roles_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": "BEGIN INSERT INTO Roles (RolesName) VALUES ('administrador'); INSERT INTO Roles (RolesName) VALUES ('operador'); INSERT INTO Roles (RolesName) VALUES ('tecnico'); END;"
    },
    {
      "TableName": "Station",
      "CommandToCreateTable": "CREATE TABLE station (ID INTEGER PRIMARY KEY,Name VARCHAR2(50) UNIQUE NOT NULL,SizeX NUMBER(10) NOT NULL,SizeY NUMBER(10) NOT NULL,Created DATE,LastUpdated DATE)",
      "CommandToSequence": "CREATE SEQUENCE station_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER station_trigger BEFORE INSERT ON station FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT station_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "Line",
      "CommandToCreateTable": "CREATE TABLE line (ID INTEGER PRIMARY KEY,Name VARCHAR2(255) UNIQUE NOT NULL,Created DATE NOT NULL,LastUpdated DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE line_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER line_trigger BEFORE INSERT ON line FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT line_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "MonitorEsd",
      "CommandToCreateTable": "CREATE TABLE monitorEsd (ID NUMBER PRIMARY KEY,SerialNumberEsp VARCHAR2(100) UNIQUE NOT NULL,Description VARCHAR2(250),Created DATE NOT NULL,LastUpdated DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE monitorEsd_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER monitorEsd_trigger BEFORE INSERT ON monitorEsd FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT monitorEsd_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "LogMonitorEsd",
      "CommandToCreateTable": "CREATE TABLE LogMonitorEsd (ID NUMBER PRIMARY KEY, SerialNumberEsp VARCHAR2(100) NOT NULL, MessageType VARCHAR2(250), MonitorEsdID INTEGER NOT NULL, JigId NUMBER(38), IP VARCHAR2(250) NOT NULL, Status NUMBER(1) CHECK (Status IN (0, 1)), MessageContent VARCHAR2(250), Description VARCHAR2(250), Created DATE NOT NULL, LastUpdated DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE logMonitorEsd_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER logMonitorEsd_trigger BEFORE INSERT ON LogMonitorEsd FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT logMonitorEsd_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    }
,
    {
      "TableName": "LastLogMonitorEsd",
      "CommandToCreateTable": "CREATE TABLE LastLogMonitorEsd (ID NUMBER PRIMARY KEY, SerialNumberEsp VARCHAR2(100) NOT NULL, MessageType VARCHAR2(250), MonitorEsdID INTEGER NOT NULL, JigId NUMBER(38), IP VARCHAR2(250) NOT NULL, Status NUMBER(1) CHECK (Status IN (0, 1)), MessageContent VARCHAR2(250), Description VARCHAR2(250), Created DATE NOT NULL, LastUpdated DATE NOT NULL,CONSTRAINT fk_lastlog_monitoresd FOREIGN KEY (MonitorEsdId) REFERENCES monitorEsd(ID))",
      "CommandToSequence": "CREATE SEQUENCE lasLogMonitorEsd_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER lasLogMonitorEsd_trigger BEFORE INSERT ON LastLogMonitorEsd FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT lasLogMonitorEsd_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "LinkStationAndLine",
      "CommandToCreateTable": "CREATE TABLE linkStationAndLine (ID INTEGER PRIMARY KEY,OrdersList INTEGER NOT NULL,LineID INTEGER NOT NULL,StationID INTEGER NOT NULL,Created DATE,LastUpdated DATE,CONSTRAINT fk_line FOREIGN KEY (LineID) REFERENCES line(ID),CONSTRAINT fk_station FOREIGN KEY (StationID) REFERENCES station(ID))",
      "CommandToSequence": "CREATE SEQUENCE linkStationAndLine_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER linkStationAndLine_trigger BEFORE INSERT ON linkStationAndLine FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT linkStationAndLine_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "StationView",
      "CommandToCreateTable": "CREATE TABLE stationView (ID INTEGER PRIMARY KEY,MonitorEsdId INTEGER UNIQUE NOT NULL,LinkStationAndLineId INTEGER NOT NULL,PositionSequence INTEGER NOT NULL,Created DATE NOT NULL,LastUpdated DATE NOT NULL,CONSTRAINT fk_linkStationAndLine FOREIGN KEY (LinkStationAndLineId) REFERENCES linkStationAndLine(ID),CONSTRAINT fk_monitor FOREIGN KEY (MonitorEsdId) REFERENCES monitorEsd(ID))",
      "CommandToSequence": "CREATE SEQUENCE stationView_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER stationView_trigger BEFORE INSERT ON stationView FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT stationView_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "ProduceActivity",
      "CommandToCreateTable": "CREATE TABLE produceActivity (ID INTEGER PRIMARY KEY,UserId INTEGER NOT NULL,JigId INTEGER NOT NULL,MonitorEsdId INTEGER NOT NULL,LinkStationAndLineID INTEGER,IsLocked NUMBER(1) CHECK (IsLocked IN (0, 1)),Description VARCHAR2(250),Created DATE NOT NULL,LastUpdated DATE NOT NULL,CONSTRAINT fk_produceActivity_jig FOREIGN KEY (JigId) REFERENCES jig(ID),CONSTRAINT fk_produceActivity_monitor FOREIGN KEY (MonitorEsdId) REFERENCES monitorEsd(ID),CONSTRAINT fk_produceActivity_user FOREIGN KEY (UserId) REFERENCES users(ID),CONSTRAINT fk_produceActivity_linkStLine FOREIGN KEY (LinkStationAndLineID) REFERENCES linkStationAndLine(ID))",
      "CommandToSequence": "CREATE SEQUENCE produceActivity_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER produceActivity_trigger BEFORE INSERT ON produceActivity FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT produceActivity_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "RecordStatusProduce",
      "CommandToCreateTable": "CREATE TABLE recordStatusProduce (ID INTEGER PRIMARY KEY,ProduceActivityID INTEGER NOT NULL,UserId INTEGER NOT NULL,Description VARCHAR2(250),Status NUMBER,DateEvent DATE,CONSTRAINT fk_produceActivity FOREIGN KEY (ProduceActivityID) REFERENCES produceActivity(ID),CONSTRAINT fk_user FOREIGN KEY (UserId) REFERENCES users(ID))",
      "CommandToSequence": "CREATE SEQUENCE recordStatusProduce_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER recordStatusProduce_trigger BEFORE INSERT ON recordStatusProduce FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT recordStatusProduce_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": ""
    },
    {
      "TableName": "fc_embedding",
      "CommandToCreateTable": "CREATE TABLE fc_embedding (ID INTEGER PRIMARY KEY, UserId INTEGER NOT NULL, embedding_Value VARCHAR2(40), CONSTRAINT fk_embedding_users FOREIGN KEY (UserId) REFERENCES users(ID))",
      "CommandToSequence": "CREATE SEQUENCE fc_embedding_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER fc_embedding_trigger BEFORE INSERT ON fc_embedding FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT fc_embedding_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": "",
      "CommandToIndex": "CREATE INDEX idx_fc_embedding_userid ON fc_embedding (USERID);"
    },
    {
      "TableName": "fc_area",
      "CommandToCreateTable": "CREATE TABLE fc_area (ID INTEGER PRIMARY KEY, UserId INTEGER NOT NULL, face_confidence VARCHAR2(10), h VARCHAR2(5), w VARCHAR2(5), x VARCHAR2(5), y VARCHAR2(5), CONSTRAINT fk_area_users FOREIGN KEY (UserId) REFERENCES users(ID))",
      "CommandToSequence": "CREATE SEQUENCE fc_area_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER fc_area_trigger BEFORE INSERT ON fc_area FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT fc_area_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": "",
      "CommandToIndex": "CREATE INDEX idx_fc_area_userid ON fc_area (USERID);"
    },
    {
      "TableName": "fc_eye",
      "CommandToCreateTable": "CREATE TABLE fc_eye (ID INTEGER PRIMARY KEY, UserId INTEGER NOT NULL, left_eye VARCHAR2(10), left_right VARCHAR2(10), CONSTRAINT fk_eye_users FOREIGN KEY (UserId) REFERENCES users(ID))",
      "CommandToSequence": "CREATE SEQUENCE fc_eye_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER fc_eye_trigger BEFORE INSERT ON fc_eye FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT fc_eye_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToPopulete": "",
      "CommandToIndex": "CREATE INDEX idx_fc_eye_userid ON fc_eye (USERID);"
    },
    {
      "TableName": "StatusJigAndUser",
      "CommandToCreateTable": "CREATE TABLE StatusJigAndUser (ID NUMBER(38) PRIMARY KEY, MONITORESDID NUMBER(38) NOT NULL, STATUS NUMBER(1) CHECK (STATUS IN (0, 1)), LASTUPDATED DATE NOT NULL)",
      "CommandToSequence": "CREATE SEQUENCE statusJigAndUser_seq START WITH 1 INCREMENT BY 1",
      "CommandToTrigger": "CREATE TRIGGER statusJigAndUser_trigger BEFORE INSERT ON StatusJigAndUser FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN SELECT statusJigAndUser_seq.NEXTVAL INTO :NEW.ID FROM dual; END;",
      "CommandToTrigger1": "CREATE OR REPLACE TRIGGER trg_update_status_jig_user AFTER INSERT ON logmonitoresd FOR EACH ROW BEGIN IF :NEW.messagetype = 'operador' THEN MERGE INTO StatusJigAndUser sju USING dual ON (sju.MONITORESDID = :NEW.MONITORESDID) WHEN MATCHED THEN UPDATE SET sju.STATUS = :NEW.STATUS, sju.LASTUPDATED = SYSDATE WHEN NOT MATCHED THEN INSERT (ID, MONITORESDID, STATUS, LASTUPDATED) VALUES (statusJigAndUser_seq.NEXTVAL, :NEW.MONITORESDID, :NEW.STATUS, SYSDATE); END IF; IF :NEW.messagetype = 'jig' THEN MERGE INTO StatusJigAndUser sju USING dual ON (sju.MONITORESDID = :NEW.MONITORESDID) WHEN MATCHED THEN UPDATE SET sju.STATUS = :NEW.STATUS, sju.LASTUPDATED = SYSDATE WHEN NOT MATCHED THEN INSERT (ID, MONITORESDID, STATUS, LASTUPDATED) VALUES (statusJigAndUser_seq.NEXTVAL, :NEW.MONITORESDID, :NEW.STATUS, SYSDATE); END IF; END;"
    }




  ],

  "Authentication": [
    {
      "Username": "admin",
      "RolesName": "administrador",
      "Badge": "admincompal",
      "Password": "admcompal"
    }
  ]
 
}
